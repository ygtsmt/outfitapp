const functions = require('firebase-functions');
const admin = require('firebase-admin');
const crypto = require('crypto');

admin.initializeApp();

exports.polloWebhook = functions.https.onRequest(async (req, res) => {
  // CORS headers
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, POST');
  res.set('Access-Control-Allow-Headers', 'Content-Type, X-Webhook-Id, X-Webhook-Timestamp, X-Webhook-Signature');

  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    // Webhook headers'Ä± al
    const webhookId = req.headers['x-webhook-id'];
    const webhookTimestamp = req.headers['x-webhook-timestamp'];
    const signature = req.headers['x-webhook-signature'];

    if (!webhookId || !webhookTimestamp || !signature) {
      console.error('Missing webhook headers');
      res.status(400).send('Missing webhook headers');
      return;
    }

    // Webhook secret'Ä± environment variable'dan al
    const secret = functions.config().pollo?.webhook_secret;
    if (!secret) {
      console.error('Webhook secret not configured');
      res.status(500).send('Webhook secret not configured');
      return;
    }

    // Request body'yi al
    const body = JSON.stringify(req.body);
    
    // Signature'Ä± doÄŸrula
    const signedContent = `${webhookId}.${webhookTimestamp}.${body}`;
    const secretBytes = Buffer.from(secret, 'base64');
    const computedSignature = crypto
      .createHmac('sha256', secretBytes)
      .update(signedContent)
      .digest('base64');

    // Signature'larÄ± karÅŸÄ±laÅŸtÄ±r (timing-safe comparison)
    if (!crypto.timingSafeEqual(
      Buffer.from(signature, 'base64'),
      Buffer.from(computedSignature, 'base64')
    )) {
      console.error('Invalid webhook signature');
      res.status(401).send('Invalid signature');
      return;
    }

    // Webhook data'sÄ±nÄ± parse et
    const event = req.body;
    const { taskId, status } = event;

    if (!taskId || !status) {
      console.error('Invalid webhook payload');
      res.status(400).send('Invalid webhook payload');
      return;
    }

    console.log(`Webhook received: taskId=${taskId}, status=${status}`);

    // EÄŸer video baÅŸarÄ±lÄ± olduysa, userGeneratedVideos array'ini gÃ¼ncelle
    if (status === 'succeed') {
      try {
        // Firestore database referansÄ±nÄ± al
        const db = admin.firestore();
        
        // Webhook'tan video URL'ini al
        let videoUrl = null;
        if (event.generations && event.generations.length > 0) {
          const generation = event.generations[0];
          if (generation.url && generation.url.length > 0) {
            videoUrl = generation.url;
            console.log(`Video URL from webhook: ${videoUrl}`);
          }
        }
        
        if (videoUrl) {
          console.log(`ðŸ“¥ Downloading video from temporary URL: ${videoUrl}`);
          
          try {
            // Videoyu indir ve Firebase Storage'a yÃ¼kle
            const firebaseUrl = await downloadAndUploadVideoToFirebase(videoUrl, taskId);
            
            if (firebaseUrl) {
              console.log(`âœ… Video uploaded to Firebase Storage: ${firebaseUrl}`);
              
              // TÃ¼m kullanÄ±cÄ±larÄ± kontrol et ve userGeneratedVideos array'inde video'yu bul
              const usersSnapshot = await db.collection('users').get();
              let videoFound = false;
              
              for (const userDoc of usersSnapshot.docs) {
                const userId = userDoc.id;
                const userData = userDoc.data();
                const userGeneratedVideos = userData?.userGeneratedVideos || [];
                
                // userGeneratedVideos array'inde video'yu bul
                const updatedVideos = userGeneratedVideos.map(video => {
                  if (video.id === taskId) {
                    videoFound = true;
                    console.log(`Found matching video for user ${userId}! Updating output from '${video.output}' to '${firebaseUrl}'`);
                    return {
                      ...video,
                      output: firebaseUrl, // Firebase Storage URL'i kullan
                      status: 'succeeded',
                      completedAt: new Date().toISOString()
                    };
                  }
                  return video;
                });
                
                if (videoFound) {
                                        // Firebase'i gÃ¼ncelle
                      await db.collection('users').doc(userId).update({
                        userGeneratedVideos: updatedVideos,
                        lastVideoUpdate: new Date().toISOString() // Library update trigger
                      });
                      console.log(`âœ… Successfully updated video output in userGeneratedVideos for taskId: ${taskId}, URL: ${firebaseUrl}, User: ${userId}`);
                      
                      // Library update trigger set edildi
                  
                  // Video bulundu, diÄŸer kullanÄ±cÄ±larÄ± kontrol etmeye gerek yok
                  break;
                }
              }
              
              if (!videoFound) {
                console.log(`âŒ Video not found in any user's userGeneratedVideos array for taskId: ${taskId}`);
              }
            } else {
              console.log(`âŒ Failed to upload video to Firebase Storage`);
            }
          } catch (uploadError) {
            console.error('Error uploading video to Firebase Storage:', uploadError);
          }
        } else {
          console.log(`âŒ No video URL found in webhook generations`);
        }
      } catch (updateError) {
        console.error('Error updating userGeneratedVideos:', updateError);
      }
    }
    
    // EÄŸer video failed olduysa, userGeneratedVideos array'inde status'u gÃ¼ncelle
    if (status === 'failed') {
      try {
        console.log(`âŒ Video failed for taskId: ${taskId}`);
        
        // Firestore database referansÄ±nÄ± al
        const db = admin.firestore();
        
        // Hata mesajÄ±nÄ± al (yeni format: result array)
        let failMsg = '';
        if (event.result && event.result.length > 0) {
          failMsg = event.result[0].failMsg || '';
        }
        console.log(`Fail message: ${failMsg}`);
        
        // TÃ¼m kullanÄ±cÄ±larÄ± kontrol et ve userGeneratedVideos array'inde video'yu bul
        const usersSnapshot = await db.collection('users').get();
        let videoFound = false;
        
        for (const userDoc of usersSnapshot.docs) {
          const userId = userDoc.id;
          const userData = userDoc.data();
          const userGeneratedVideos = userData?.userGeneratedVideos || [];
          
          // userGeneratedVideos array'inde video'yu bul
          const updatedVideos = userGeneratedVideos.map(video => {
            if (video.id === taskId) {
              videoFound = true;
              console.log(`Found matching failed video for user ${userId}! Updating status to 'failed'`);
              return {
                ...video,
                status: 'failed',
                error: failMsg, // Hata mesajÄ±nÄ± ekle
                completedAt: new Date().toISOString()
              };
            }
            return video;
          });
          
          if (videoFound) {
            // Firebase'i gÃ¼ncelle
            await db.collection('users').doc(userId).update({
              userGeneratedVideos: updatedVideos,
              lastVideoUpdate: new Date().toISOString() // Library update trigger
            });
            console.log(`âœ… Successfully updated failed video status in userGeneratedVideos for taskId: ${taskId}, User: ${userId}`);
            
            // Library update trigger set edildi
            break;
          }
        }
        
        if (!videoFound) {
          console.log(`âŒ Failed video not found in any user's userGeneratedVideos array for taskId: ${taskId}`);
        }
      } catch (updateError) {
        console.error('Error updating failed video status:', updateError);
      }
    }

    res.status(200).send('OK');
  } catch (error) {
    console.error('Webhook processing error:', error);
    res.status(500).send('Internal Server Error');
  }
});

// ===== FAL AI WEBHOOK =====
exports.falWebhook = functions.https.onRequest(async (req, res) => {
  // CORS headers
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, POST');
  res.set('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    console.log('ðŸŽ¯ Fal AI Webhook received:', JSON.stringify(req.body, null, 2));
    
    const event = req.body;
    const { request_id, status, payload } = event;

    if (!request_id) {
      console.error('Invalid Fal AI webhook payload - missing request_id');
      res.status(400).send('Invalid webhook payload');
      return;
    }

    console.log(`Fal AI Webhook received: requestId=${request_id}, status=${status}`);

    // EÄŸer video baÅŸarÄ±lÄ± olduysa, userGeneratedVideos array'ini gÃ¼ncelle
    if (status === 'OK' && payload) {
      try {
        // Firestore database referansÄ±nÄ± al
        const db = admin.firestore();
        
        // Webhook'tan video URL'ini al (Fal AI format: payload.video.url)
        let videoUrl = null;
        if (payload && payload.video && payload.video.url) {
          videoUrl = payload.video.url;
          console.log(`Fal AI Video URL from webhook: ${videoUrl}`);
        }
        
        if (videoUrl) {
          console.log(`ðŸ“¥ Downloading Fal AI video from temporary URL: ${videoUrl}`);
          
          try {
            // Videoyu indir ve Firebase Storage'a yÃ¼kle
            const firebaseUrl = await downloadAndUploadVideoToFirebase(videoUrl, request_id);
            
            if (firebaseUrl) {
              console.log(`âœ… Fal AI Video uploaded to Firebase Storage: ${firebaseUrl}`);
              
              // TÃ¼m kullanÄ±cÄ±larÄ± kontrol et ve userGeneratedVideos array'inde video'yu bul
              const usersSnapshot = await db.collection('users').get();
              let videoFound = false;
              
              for (const userDoc of usersSnapshot.docs) {
                const userId = userDoc.id;
                const userData = userDoc.data();
                const userGeneratedVideos = userData?.userGeneratedVideos || [];
                
                // userGeneratedVideos array'inde video'yu bul
                const updatedVideos = userGeneratedVideos.map(video => {
                  if (video.id === request_id) {
                    videoFound = true;
                    console.log(`Found matching Fal AI video for user ${userId}! Updating output from '${video.output}' to '${firebaseUrl}'`);
                    return {
                      ...video,
                      output: firebaseUrl, // Firebase Storage URL'i kullan
                      status: 'succeeded',
                      completedAt: new Date().toISOString()
                    };
                  }
                  return video;
                });
                
                if (videoFound) {
                  // Firebase'i gÃ¼ncelle
                  await db.collection('users').doc(userId).update({
                    userGeneratedVideos: updatedVideos,
                    lastVideoUpdate: new Date().toISOString() // Library update trigger
                  });
                  console.log(`âœ… Successfully updated Fal AI video output in userGeneratedVideos for requestId: ${request_id}, URL: ${firebaseUrl}, User: ${userId}`);
                  
                  // Video bulundu, diÄŸer kullanÄ±cÄ±larÄ± kontrol etmeye gerek yok
                  break;
                }
              }
              
              if (!videoFound) {
                console.log(`âŒ Fal AI Video not found in any user's userGeneratedVideos array for requestId: ${request_id}`);
              }
            } else {
              console.log(`âŒ Failed to upload Fal AI video to Firebase Storage`);
            }
          } catch (uploadError) {
            console.error('Error uploading Fal AI video to Firebase Storage:', uploadError);
          }
        } else {
          console.log(`âŒ No video URL found in Fal AI webhook output`);
        }
      } catch (updateError) {
        console.error('Error updating Fal AI userGeneratedVideos:', updateError);
      }
    }
    
    // EÄŸer video failed olduysa, userGeneratedVideos array'inde status'u gÃ¼ncelle
    if (status === 'ERROR') {
      try {
        console.log(`âŒ Fal AI Video failed for requestId: ${request_id}`);
        
        // Firestore database referansÄ±nÄ± al
        const db = admin.firestore();
        
        // Hata mesajÄ±nÄ± al (Fal AI format: error field)
        let failMsg = '';
        if (event.error) {
          failMsg = event.error;
        }
        console.log(`Fal AI Fail message: ${failMsg}`);
        
        // TÃ¼m kullanÄ±cÄ±larÄ± kontrol et ve userGeneratedVideos array'inde video'yu bul
        const usersSnapshot = await db.collection('users').get();
        let videoFound = false;
        
        for (const userDoc of usersSnapshot.docs) {
          const userId = userDoc.id;
          const userData = userDoc.data();
          const userGeneratedVideos = userData?.userGeneratedVideos || [];
          
          // userGeneratedVideos array'inde video'yu bul
          const updatedVideos = userGeneratedVideos.map(video => {
            if (video.id === request_id) {
              videoFound = true;
              console.log(`Found matching failed Fal AI video for user ${userId}! Updating status to 'failed'`);
              return {
                ...video,
                status: 'failed',
                error: failMsg, // Hata mesajÄ±nÄ± ekle
                completedAt: new Date().toISOString()
              };
            }
            return video;
          });
          
          if (videoFound) {
            // Firebase'i gÃ¼ncelle
            await db.collection('users').doc(userId).update({
              userGeneratedVideos: updatedVideos,
              lastVideoUpdate: new Date().toISOString() // Library update trigger
            });
            console.log(`âœ… Successfully updated failed Fal AI video status in userGeneratedVideos for requestId: ${request_id}, User: ${userId}`);
            
            break;
          }
        }
        
        if (!videoFound) {
          console.log(`âŒ Failed Fal AI video not found in any user's userGeneratedVideos array for requestId: ${request_id}`);
        }
      } catch (updateError) {
        console.error('Error updating failed Fal AI video status:', updateError);
      }
    }

    res.status(200).send('OK');
  } catch (error) {
    console.error('Fal AI Webhook processing error:', error);
    res.status(500).send('Internal Server Error');
  }
});

// Videoyu indir ve Firebase Storage'a yÃ¼kle
async function downloadAndUploadVideoToFirebase(videoUrl, taskId) {
  try {
    console.log(`ðŸ“¥ Starting download for taskId: ${taskId}`);
    
    // HTTP request ile videoyu indir
    const https = require('https');
    const http = require('http');
    
    const protocol = videoUrl.startsWith('https:') ? https : http;
    
    const videoBuffer = await new Promise((resolve, reject) => {
      protocol.get(videoUrl, (response) => {
        if (response.statusCode !== 200) {
          reject(new Error(`Failed to download video: ${response.statusCode}`));
          return;
        }
        
        const chunks = [];
        response.on('data', (chunk) => chunks.push(chunk));
        response.on('end', () => resolve(Buffer.concat(chunks)));
        response.on('error', reject);
      }).on('error', reject);
    });
    
    console.log(`ðŸ“¥ Video downloaded, size: ${videoBuffer.length} bytes`);
    
    // Firebase Storage'a yÃ¼kle
    const bucket = admin.storage().bucket();
    const fileName = `user_videos/${taskId}/${Date.now()}.mp4`;
    const file = bucket.file(fileName);
    
    await file.save(videoBuffer, {
      metadata: {
        contentType: 'video/mp4',
        metadata: {
          taskId: taskId,
          uploadedAt: new Date().toISOString()
        }
      }
    });
    
    console.log(`ðŸ“¤ Video uploaded to Firebase Storage: ${fileName}`);
    
    // Public URL oluÅŸtur
    await file.makePublic();
    const publicUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
    
    console.log(`ðŸ”— Public URL created: ${publicUrl}`);
    return publicUrl;
    
  } catch (error) {
    console.error('Error in downloadAndUploadVideoToFirebase:', error);
    return null;
  }
}

// Webhook secret'Ä± set etmek iÃ§in helper function
exports.setWebhookSecret = functions.https.onRequest(async (req, res) => {
  if (req.method !== 'POST') {
    res.status(405).send('Method Not Allowed');
    return;
  }

  try {
    const { secret } = req.body;
    if (!secret) {
      res.status(400).send('Secret is required');
      return;
    }

    // Webhook secret'Ä± set et
    await functions.config().set({
      pollo: {
        webhook_secret: secret
      }
    });

    res.status(200).send('Webhook secret configured successfully');
  } catch (error) {
    console.error('Error setting webhook secret:', error);
    res.status(500).send('Error setting webhook secret');
  }
});

// ===== REVENUECAT PAYMENT SYSTEM =====

// Cloud Tasks client
const {CloudTasksClient} = require('@google-cloud/tasks');
const tasksClient = new CloudTasksClient();

// RevenueCat proje bilgileri
const project = 'disciplify-26970'; // Firebase proje ID'n
const queue = 'payment-processing';
const location = 'us-central1';

// Test function kaldÄ±rÄ±ldÄ±

// RevenueCat Webhook Handler
exports.revenueCatWebhook = functions.https.onRequest(async (req, res) => {
  // CORS headers
  res.set('Access-Control-Allow-Origin', '*');
  res.set('Access-Control-Allow-Methods', 'GET, POST');
  res.set('Access-Control-Allow-Headers', 'Content-Type');

  if (req.method === 'OPTIONS') {
    res.status(204).send('');
    return;
  }

  try {
    console.log(' RevenueCat Webhook received:', req.body);
    
    // RevenueCat test event'leri iÃ§in Ã¶zel handling
    let eventData = req.body;
    
    // EÄŸer test event ise, event objesi iÃ§inden al
    if (req.body.event && req.body.event.type === 'TEST') {
      eventData = {
        event_type: 'TEST_INITIAL_PURCHASE', // Test iÃ§in Ã¶zel event type
        app_user_id: req.body.event.app_user_id,
        product_id: req.body.event.product_id,
        entitlement_id: null,
        cancellation_reason: null,
        refund_reason: null
      };
      console.log('ðŸ§ª Test event detected, using event data');
    } else {
      // Normal webhook event
      eventData = {
        event_type: req.body.event_type || req.body.event?.type,
        app_user_id: req.body.app_user_id || req.body.event?.app_user_id,
        product_id: req.body.product_id || req.body.event?.product_id,
        entitlement_id: req.body.entitlement_id || req.body.event?.entitlement_id,
        cancellation_reason: req.body.cancellation_reason,
        refund_reason: req.body.refund_reason
      };
    }

    // Gerekli alanlarÄ± kontrol et
    if (!eventData.app_user_id || !eventData.event_type || !eventData.product_id) {
      console.error('âŒ Missing required fields:', req.body);
      return res.status(400).json({ 
        error: 'Missing required fields',
        required: ['app_user_id', 'event_type', 'product_id'],
        received: eventData
      });
    }

    // Cloud Task oluÅŸtur
    const taskResult = await _createPaymentTask({
      userId: eventData.app_user_id,
      eventType: eventData.event_type,
      productId: eventData.product_id,
      entitlementId: eventData.entitlement_id,
      cancellationReason: eventData.cancellation_reason,
      refundReason: eventData.refund_reason,
      timestamp: Date.now(),
      webhookData: req.body
    });

    console.log('âœ… Payment task created successfully:', taskResult.name);

    // BaÅŸarÄ±lÄ± response
    res.status(200).json({ 
      success: true, 
      message: 'Payment event queued for processing',
      taskId: taskResult.name,
      eventType: eventData.event_type,
      userId: eventData.app_user_id
    });

  } catch (error) {
    console.error('âŒ Webhook processing error:', error);
    
    // Error response
    res.status(500).json({ 
      error: 'Failed to process webhook',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Cloud Task oluÅŸturma fonksiyonu
async function _createPaymentTask(eventData) {
  try {
    console.log('ðŸ“ Creating payment task for:', eventData);
    
    const parent = tasksClient.queuePath(project, location, queue);
    
    const task = {
      httpRequest: {
        httpMethod: 'POST',
        url: `https://${location}-${project}.cloudfunctions.net/processPaymentEvent`,
        body: Buffer.from(JSON.stringify(eventData)).toString('base64'),
        headers: {
          'Content-Type': 'application/json',
        },
        // Task timeout: 10 dakika
        timeout: { seconds: 600 },
        // Retry ayarlarÄ±
        retryConfig: {
          maxAttempts: 3,
          maxRetryDuration: { seconds: 300 },
          minBackoff: { seconds: 1 },
          maxBackoff: { seconds: 60 },
          maxDoublings: 3
        }
      },
      // Task priority
      dispatchDeadline: { seconds: 600 }
    };
    
    const [response] = await tasksClient.createTask({parent, task});
    console.log(`âœ… Payment task created: ${response.name}`);
    
    return response;
    
  } catch (error) {
    console.error('âŒ Failed to create Cloud Task:', error);
    throw error;
  }
}

// Payment event'i iÅŸleyen function
exports.processPaymentEvent = functions.https.onRequest(async (req, res) => {
  try {
    console.log(' Processing payment event:', req.body);
    
    const eventData = req.body;
    
    // Gerekli alanlarÄ± kontrol et
    if (!eventData.userId || !eventData.eventType || !eventData.productId) {
      console.error('âŒ Missing required fields in payment event:', eventData);
      return res.status(400).json({ 
        error: 'Missing required fields',
        required: ['userId', 'eventType', 'productId']
      });
    }

    // Payment event'i iÅŸle
    const result = await _processPaymentEvent(eventData);
    
    console.log('âœ… Payment event processed successfully:', result);
    
    // BaÅŸarÄ±lÄ± response
    res.status(200).json({ 
      success: true, 
      message: 'Payment processed successfully',
      userId: eventData.userId,
      eventType: eventData.eventType,
      result: result
    });
    
  } catch (error) {
    console.error('âŒ Payment processing error:', error);
    
    // Error response (Cloud Tasks retry yapar)
    res.status(500).json({ 
      error: 'Payment processing failed',
      details: error.message,
      retry: true,
      timestamp: new Date().toISOString()
    });
  }
});

// Ana payment processing logic - User payment data yazÄ±yor
async function _processPaymentEvent(eventData) {
  const { 
    userId, 
    eventType, 
    productId, 
    entitlementId, 
    cancellationReason, 
    refundReason,
    webhookData 
  } = eventData;
  
  console.log(`ðŸ“ Processing ${eventType} for user ${userId}, product ${productId}`);
  console.log(`ðŸ“Š Event data:`, eventData);
  
  try {
    // User dokÃ¼manÄ±na payment bilgilerini yaz
    const userRef = admin.firestore().collection('users').doc(userId);
    
    // Event type'a gÃ¶re farklÄ± iÅŸlemler
    switch (eventType) {
      case 'INITIAL_PURCHASE':
        await _handleInitialPurchase(userRef, productId, entitlementId, webhookData);
        break;
        
      case 'RENEWAL':
        await _handleRenewal(userRef, productId, webhookData);
        break;
        
      case 'CANCELLATION':
        await _handleCancellation(userRef, productId, cancellationReason, webhookData);
        break;
        
      case 'EXPIRATION':
        await _handleExpiration(userRef, productId, webhookData);
        break;
        
      case 'REFUND':
        await _handleRefund(userRef, productId, refundReason, webhookData);
        break;
        
      // One-time purchase event'leri
      case 'NON_RENEWING_PURCHASE':
      case 'ONE_TIME_PURCHASE':
        await _handleOneTimePurchase(userRef, productId, webhookData);
        break;
        
      default:
        console.log(`âš ï¸ Unknown event type: ${eventType}, only logging`);
        return { 
          status: 'unknown_event', 
          eventType, 
          userId, 
          productId,
          message: 'Unknown event type, only logged'
        };
    }
    
    console.log(`âœ… Payment data written to Firestore for ${eventType}`);
    return { 
      status: 'payment_data_written', 
      eventType, 
      userId, 
      productId,
      message: 'Payment data written to user document'
    };
    
  } catch (error) {
    console.error('âŒ Error writing payment data:', error);
    throw error;
  }
}

// Credit Management Helper Functions

// Firebase'den plan bilgilerini Ã§ek
async function _getPlanFromFirebase(productId) {
  try {
    const planDoc = await admin.firestore().collection('plans').doc(productId).get();
    if (planDoc.exists) {
      const planData = planDoc.data();
      return {
        purchasedCredit: planData.purchased_credit || 0,
        benefits: planData.benefits || {}
      };
    }
    return null;
  } catch (error) {
    console.error('âŒ Error getting plan from Firebase:', error);
    return null;
  }
}

// Plan tipine gÃ¶re haftalÄ±k kredi hesapla (Firebase'den)
async function _getWeeklyCredits(productId) {
  const plan = await _getPlanFromFirebase(productId);
  if (plan && plan.purchasedCredit > 0) {
    return plan.purchasedCredit;
  }
  
  // Firebase'de plan bulunamazsa hata logla
  console.error(`âŒ Plan not found in Firebase: ${productId}`);
  return 0; // Plan bulunamazsa 0 dÃ¶ndÃ¼r
}

// One-time purchase iÃ§in kredi hesapla (Firebase'den)
async function _getOneTimePurchaseCredits(productId) {
  const plan = await _getPlanFromFirebase(productId);
  if (plan && plan.purchasedCredit > 0) {
    return plan.purchasedCredit;
  }
  
  // Firebase'de plan bulunamazsa hata logla
  console.error(`âŒ One-time plan not found in Firebase: ${productId}`);
  return 0; // Plan bulunamazsa 0 dÃ¶ndÃ¼r
}

// KullanÄ±cÄ±nÄ±n mevcut kredilerini al
async function _getCurrentCredits(userRef) {
  try {
    const userDoc = await userRef.get();
    if (userDoc.exists) {
      const profileInfo = userDoc.data()?.profile_info;
      return profileInfo?.totalCredit || 0;
    }
    return 0;
  } catch (error) {
    console.error('âŒ Error getting current credits:', error);
    return 0;
  }
}

// Kredileri gÃ¼ncelle
async function _updateCredits(userRef, creditChange, reason) {
  try {
    const currentCredits = await _getCurrentCredits(userRef);
    const newCredits = Math.max(0, currentCredits + creditChange); // Negatif olmasÄ±n
    
    await userRef.update({
      'profile_info.totalCredit': newCredits,
      'profile_info.lastCreditUpdate': admin.firestore.FieldValue.serverTimestamp()
    });
    
    console.log(`âœ… Credits updated: ${currentCredits} â†’ ${newCredits} (${reason})`);
    return newCredits;
  } catch (error) {
    console.error('âŒ Error updating credits:', error);
    throw error;
  }
}

// Log ekleme helper function
async function _addLog(userRef, logMessage) {
  try {
    const timestamp = new Date().toLocaleString('tr-TR', {
      timeZone: 'Europe/Istanbul',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    
    const fullLogMessage = `[${timestamp}] ${logMessage}`;
    
    await userRef.update({
      'purchased_info.logs': admin.firestore.FieldValue.arrayUnion(fullLogMessage)
    });
    
    console.log(`ðŸ“ Log added: ${fullLogMessage}`);
  } catch (error) {
    console.error('âŒ Error adding log:', error);
  }
}

// One-time purchase log ekleme helper function
async function _addOneTimePurchaseLog(userRef, logMessage) {
  try {
    const timestamp = new Date().toLocaleString('tr-TR', {
      timeZone: 'Europe/Istanbul',
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    });
    
    const fullLogMessage = `[${timestamp}] ${logMessage}`;
    
    await userRef.update({
      'one_time_purchased_logs': admin.firestore.FieldValue.arrayUnion(fullLogMessage)
    });
    
    console.log(`ðŸ“ One-time purchase log added: ${fullLogMessage}`);
  } catch (error) {
    console.error('âŒ Error adding one-time purchase log:', error);
  }
}

// Mevcut refund counter'Ä± al
async function _getCurrentRefundCount(userRef) {
  try {
    const userDoc = await userRef.get();
    if (userDoc.exists) {
      const purchasedInfo = userDoc.data()?.purchased_info;
      return purchasedInfo?.refund_from_store || 0;
    }
    return 0;
  } catch (error) {
    console.error('âŒ Error getting refund count:', error);
    return 0;
  }
}

// Handler Functions - User payment data yazÄ±yor

async function _handleInitialPurchase(userRef, productId, entitlementId, webhookData) {
  const event = webhookData.event;
  
  // HaftalÄ±k kredileri hesapla (Firebase'den)
  const weeklyCredits = await _getWeeklyCredits(productId);
  
  // Kredileri ekle
  await _updateCredits(userRef, weeklyCredits, `Initial purchase: ${productId}`);
  
  // Plan adÄ±nÄ± belirle
  const planName = productId.includes('plus') ? 'Plus' : productId.includes('pro') ? 'Pro' : 'Ultra';
  
  await userRef.set({
    'purchased_info': {
      'current_plan_id': productId,
      'subscription_status': 'active',
      'entitlement_id': entitlementId,
      'subscription_start_date': admin.firestore.FieldValue.serverTimestamp(),
      'last_updated': admin.firestore.FieldValue.serverTimestamp(),
      'weekly_credits': weeklyCredits, // HaftalÄ±k kredi miktarÄ±
      'refund_from_store': 0, // Refund counter baÅŸlat
      'logs': [], // Log array'i baÅŸlat
      'plan_history': [{
        'action': 'initial_purchase',
        'product_id': productId,
        'timestamp': new Date().toISOString(),
        'status': 'active',
        'transaction_id': event.transaction_id,
        'price': event.price,
        'currency': event.currency,
        'country_code': event.country_code,
        'store': event.store,
        'credits_added': weeklyCredits
      }],
      'subscription_details': {
        'product_id': productId,
        'status': 'active',
        'start_date': admin.firestore.FieldValue.serverTimestamp(),
        'auto_renew': true,
        'renewal_number': event.renewal_number || 1,
        'expiration_date': new Date(event.expiration_at_ms),
        'purchase_date': new Date(event.purchased_at_ms)
      }
    },

  }, { merge: true });
  
  // DetaylÄ± log ekle
  const environment = event.environment || 'UNKNOWN';
  await _addLog(userRef, `ðŸŽ‰ Ä°lk abonelik baÅŸarÄ±yla oluÅŸturuldu! Plan: ${planName}, HaftalÄ±k Kredi: ${weeklyCredits}, Fiyat: ${event.price} ${event.currency}, Ãœlke: ${event.country_code}, Store: ${event.store === 'PLAY_STORE' ? 'Google Play' : 'App Store'}, Environment: ${environment}, Periyot: ${environment === 'SANDBOX' ? 'TEST (HÄ±zlÄ±)' : 'PRODUCTION (1 Hafta)'}`);
  
  console.log('âœ… Initial purchase data written to user document');
}

async function _handleRenewal(userRef, productId, webhookData) {
  const event = webhookData.event;
  
  // HaftalÄ±k kredileri hesapla ve ekle (Firebase'den)
  const weeklyCredits = await _getWeeklyCredits(productId);
  await _updateCredits(userRef, weeklyCredits, `Weekly renewal: ${productId}`);
  
  // Plan adÄ±nÄ± belirle
  const planName = productId.includes('plus') ? 'Plus' : productId.includes('pro') ? 'Pro' : 'Ultra';
  
  await userRef.update({
    'purchased_info.subscription_status': 'active',
    'purchased_info.last_renewal_date': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.last_updated': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.plan_history': admin.firestore.FieldValue.arrayUnion({
      'action': 'renewal',
      'product_id': productId,
      'timestamp': new Date().toISOString(),
      'status': 'active',
      'transaction_id': event.transaction_id,
      'price': event.price,
      'currency': event.currency,
      'credits_added': weeklyCredits
    }),
    'purchased_info.subscription_details.status': 'active',
    'purchased_info.subscription_details.last_renewal': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.subscription_details.renewal_number': event.renewal_number || 1
  });
  
  // DetaylÄ± log ekle
  const environment = event.environment || 'UNKNOWN';
  const timeSinceLastRenewal = event.purchased_at_ms ? `(${Math.round((Date.now() - event.purchased_at_ms) / 1000 / 60)} dakika)` : '';
  await _addLog(userRef, `ðŸ”„ HaftalÄ±k yenileme baÅŸarÄ±lÄ±! Plan: ${planName}, Eklenen Kredi: ${weeklyCredits}, Fiyat: ${event.price} ${event.currency}, Yenileme SayÄ±sÄ±: ${event.renewal_number || 1}, Environment: ${environment}, Periyot: ${environment === 'SANDBOX' ? 'TEST (HÄ±zlÄ±)' : 'PRODUCTION (1 Hafta)'} ${timeSinceLastRenewal}`);
  
  console.log('âœ… Renewal data updated in user document');
}

async function _handleCancellation(userRef, productId, cancellationReason, webhookData) {
  // Cancellation'da kredi ekleme, sadece status gÃ¼ncelle
  // Mevcut periyot bitene kadar kredi alacak, sonra duracak
  
  await userRef.update({
    'purchased_info.subscription_status': 'cancelled',
    'purchased_info.cancellation_date': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.cancellation_reason': cancellationReason || 'user_cancelled',
    'purchased_info.last_updated': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.plan_history': admin.firestore.FieldValue.arrayUnion({
      'action': 'cancellation',
      'product_id': productId,
      'timestamp': new Date().toISOString(),
      'status': 'cancelled',
      'reason': cancellationReason,
      'credits_added': 0 // Cancellation'da kredi eklenmez
    }),
    'purchased_info.subscription_details.status': 'cancelled'
  });
  
  // DetaylÄ± log ekle
  const planName = productId.includes('plus') ? 'Plus' : productId.includes('pro') ? 'Pro' : 'Ultra';
  const reasonText = cancellationReason || 'KullanÄ±cÄ± tarafÄ±ndan iptal edildi';
  await _addLog(userRef, `âŒ Abonelik iptal edildi! Plan: ${planName}, Ä°ptal Sebebi: ${reasonText}, Not: Mevcut periyot bitene kadar kredi almaya devam edeceksiniz`);
  
  console.log('âœ… Cancellation data updated in user document - No credits added');
}

async function _handleExpiration(userRef, productId, webhookData) {
  // Expiration'da son periyot kredisi eklenmiÅŸ, artÄ±k ekleme yok
  
  await userRef.update({
    'purchased_info.subscription_status': 'expired',
    'purchased_info.expiration_date': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.last_updated': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.plan_history': admin.firestore.FieldValue.arrayUnion({
      'action': 'expiration',
      'product_id': productId,
      'timestamp': new Date().toISOString(),
      'status': 'expired',
      'credits_added': 0 // Expiration'da kredi eklenmez
    }),
    'purchased_info.subscription_details.status': 'expired'
  });
  
  console.log('âœ… Expiration data updated in user document - No credits added');
}

async function _handleRefund(userRef, productId, refundReason, webhookData) {
  // Refund'da akÄ±llÄ± kredi hesaplama
  const weeklyCredits = await _getWeeklyCredits(productId);
  const currentCredits = await _getCurrentCredits(userRef);
  
  // HarcanmamÄ±ÅŸ kredileri hesapla
  const unusedCredits = Math.min(weeklyCredits, currentCredits);
  
  // Sadece harcanmamÄ±ÅŸ kredileri geri al
  if (unusedCredits > 0) {
    await _updateCredits(userRef, -unusedCredits, `Refund: ${productId} - Unused credits removed`);
  }
  
  await userRef.update({
    'purchased_info.subscription_status': 'refunded',
    'purchased_info.refund_date': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.refund_reason': refundReason || 'user_requested',
    'purchased_info.last_updated': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.refund_from_store': admin.firestore.FieldValue.increment(1), // Refund counter +1
    'purchased_info.plan_history': admin.firestore.FieldValue.arrayUnion({
      'action': 'refund',
      'product_id': productId,
      'timestamp': new Date().toISOString(),
      'status': 'refunded',
      'reason': refundReason,
      'credits_removed': unusedCredits, // GerÃ§ekte geri alÄ±nan kredi
      'total_credits_from_plan': weeklyCredits, // Plandan gelen toplam kredi
      'unused_credits_refunded': unusedCredits, // Geri alÄ±nan kullanÄ±lmamÄ±ÅŸ kredi
      'spent_credits': weeklyCredits - unusedCredits // Harcanan kredi
    }),
    'purchased_info.subscription_details.status': 'refunded'
  });
  
  // DetaylÄ± log ekle
  const planName = productId.includes('plus') ? 'Plus' : productId.includes('pro') ? 'Pro' : 'Ultra';
  const reasonText = refundReason || 'KullanÄ±cÄ± tarafÄ±ndan talep edildi';
  
  // Mevcut refund counter'Ä± al
  const currentRefundCount = await _getCurrentRefundCount(userRef);
  const newRefundCount = currentRefundCount + 1;
  
  await _addLog(userRef, `ðŸ’° Ä°ade iÅŸlemi gerÃ§ekleÅŸti! Plan: ${planName}, Ä°ade Sebebi: ${reasonText}, Plandan Gelen Kredi: ${weeklyCredits}, Harcanan Kredi: ${weeklyCredits - unusedCredits}, Geri AlÄ±nan Kredi: ${unusedCredits}, Toplam Ä°ade SayÄ±sÄ±: ${newRefundCount}, Not: Sadece kullanÄ±lmamÄ±ÅŸ krediler geri alÄ±ndÄ±`);
  
  console.log('âœ… Refund data updated in user document - Smart credits calculation');
}

async function _handleRestoration(userRef, productId, entitlementId, webhookData) {
  // Restoration'da kredileri tekrar ekle
  const weeklyCredits = await _getWeeklyCredits(productId);
  await _updateCredits(userRef, weeklyCredits, `Restoration: ${productId} - Credits restored`);
  
  // Plan adÄ±nÄ± belirle
  const planName = productId.includes('plus') ? 'Plus' : productId.includes('pro') ? 'Pro' : 'Ultra';
  
  await userRef.update({
    'purchased_info.subscription_status': 'active',
    'purchased_info.restoration_date': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.last_updated': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.plan_history': admin.firestore.FieldValue.arrayUnion({
      'action': 'restoration',
      'product_id': productId,
      'timestamp': new Date().toISOString(),
      'status': 'active',
      'credits_added': weeklyCredits
    }),
    'purchased_info.subscription_details.status': 'active',
    'purchased_info.subscription_details.restoration_date': admin.firestore.FieldValue.serverTimestamp()
  });
  
  console.log('âœ… Restoration data updated in user document - Credits restored');
}

async function _handleTransfer(userRef, productId, webhookData) {
  // Transfer'da kredi ekleme, sadece status gÃ¼ncelle
  await userRef.update({
    'purchased_info.subscription_status': 'transferred',
    'purchased_info.transfer_date': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.last_updated': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.plan_history': admin.firestore.FieldValue.arrayUnion({
      'action': 'transfer',
      'product_id': productId,
      'timestamp': new Date().toISOString(),
      'status': 'transferred',
      'credits_added': 0
    }),
    'purchased_info.subscription_details.status': 'transferred'
  });
  
  console.log('âœ… Transfer data updated in user document - No credits added');
}

async function _handleUncancellation(userRef, productId, webhookData) {
  // Uncancellation'da kredileri tekrar ekle
  const weeklyCredits = await _getWeeklyCredits(productId);
  await _updateCredits(userRef, weeklyCredits, `Uncancellation: ${productId} - Credits restored`);
  
  // Plan adÄ±nÄ± belirle
  const planName = productId.includes('plus') ? 'Plus' : productId.includes('pro') ? 'Pro' : 'Ultra';
  
  await userRef.update({
    'purchased_info.subscription_status': 'active',
    'purchased_info.uncancellation_date': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.last_updated': admin.firestore.FieldValue.serverTimestamp(),
    'purchased_info.plan_history': admin.firestore.FieldValue.arrayUnion({
      'action': 'uncancellation',
      'product_id': productId,
      'timestamp': new Date().toISOString(),
      'status': 'active',
      'credits_added': weeklyCredits
    }),
    'purchased_info.subscription_details.status': 'active'
  });
  
  console.log('âœ… Uncancellation data updated in user document - Credits restored');
}

// One-time purchase handler
async function _handleOneTimePurchase(userRef, productId, webhookData) {
  const event = webhookData.event;
  
  // One-time purchase kredilerini hesapla (Firebase'den)
  const creditAmount = await _getOneTimePurchaseCredits(productId);
  
  // Mevcut kredileri al
  const currentCredits = await _getCurrentCredits(userRef);
  const newCredits = currentCredits + creditAmount;
  
  // Kredileri ekle
  await _updateCredits(userRef, creditAmount, `One-time purchase: ${productId}`);
  
  // Paket adÄ±nÄ± belirle
  const packageName = _getOneTimePackageName(productId);
  
  const updateData = {
    'one_time_purchases': admin.firestore.FieldValue.arrayUnion({
      'product_id': productId,
      'package_name': packageName,
      'credit_amount': creditAmount,
      'transaction_id': event.transaction_id,
      'purchase_date': new Date(),
      'price': event.price,
      'currency': event.currency,
      'status': 'completed'
    }),
    'profile_info.lastOneTimePurchase': admin.firestore.FieldValue.serverTimestamp(),
    'profile_info.totalOneTimePurchases': admin.firestore.FieldValue.increment(1)
  };
  
  // HÄ±zlÄ± kredi ekleme ve temel bilgiler
  await userRef.update(updateData);
  
  // One-time purchase iÃ§in ayrÄ± log sistemi
  const environment = event.environment || 'UNKNOWN';
  await _addOneTimePurchaseLog(userRef, `ðŸŽ Tek seferlik kredi paketi satÄ±n alÄ±ndÄ±! Paket: ${packageName}, Ã–nceki Kredi: ${currentCredits}, Eklenen Kredi: ${creditAmount}, Yeni Kredi: ${newCredits}, Fiyat: ${event.price} ${event.currency}, Ãœlke: ${event.country_code}, Store: ${event.store === 'PLAY_STORE' ? 'Google Play' : 'App Store'}, Environment: ${environment}`);
  
  console.log('âœ… One-time purchase data written to user document');
}

// One-time purchase paket adÄ±nÄ± belirle
function _getOneTimePackageName(productId) {
  if (productId.includes('extra')) return 'Ginly AI Extra';
  if (productId.includes('boost')) return 'Ginly AI Boost';
  if (productId.includes('mega')) return 'Ginly AI Mega';
  return 'Unknown Package';
}

// ===== PIXVERSE ORIGINAL API POLLING =====
// Pixverse URL'den videoyu indir ve Firebase Storage'a yÃ¼kle
async function uploadPixverseVideoToFirebase(pixverseUrl, userId, videoId) {
  try {
    console.log(`ðŸ“¥ Downloading video from Pixverse: ${pixverseUrl}`);
    const axios = require('axios');
    
    // Videoyu indir
    const response = await axios.get(pixverseUrl, {
      responseType: 'arraybuffer',
      timeout: 60000 // 60 saniye timeout
    });
    
    const videoBuffer = Buffer.from(response.data);
    console.log(`âœ… Video downloaded, size: ${videoBuffer.length} bytes`);
    
    // Firebase Storage'a yÃ¼kle
    const bucket = admin.storage().bucket();
    const fileName = `pixverse_videos/${userId}/${videoId}_${Date.now()}.mp4`;
    const file = bucket.file(fileName);
    
    await file.save(videoBuffer, {
      metadata: {
        contentType: 'video/mp4',
        metadata: {
          userId: userId,
          videoId: videoId,
          source: 'pixverse-original',
          uploadedAt: new Date().toISOString()
        }
      }
    });
    
    // Public URL oluÅŸtur
    await file.makePublic();
    const publicUrl = `https://storage.googleapis.com/${bucket.name}/${fileName}`;
    
    console.log(`âœ… Video uploaded to Firebase Storage: ${publicUrl}`);
    return publicUrl;
    
  } catch (error) {
    console.error(`âŒ Error uploading video to Firebase Storage:`, error.message);
    throw error;
  }
}

// Her 2 dakikada bir pending Pixverse Original videolarÄ± kontrol et
exports.checkPendingPixverseVideos = functions.pubsub
  .schedule('every 2 minutes')
  .onRun(async (context) => {
    try {
      console.log('ðŸ” Checking pending Pixverse Original videos...');
      
      const db = admin.firestore();
      const axios = require('axios');
      
      // Pixverse API key'i environment variable'dan al
      const pixverseApiKey = functions.config().pixverse?.apikey;
      if (!pixverseApiKey) {
        console.error('âŒ Pixverse API key not configured');
        return null;
      }
      
      // Sadece pending videolarÄ± olan kullanÄ±cÄ±larÄ± kontrol et
      const usersSnapshot = await db.collection('users')
        .where('hasPendingVideos', '==', true)
        .get();
      
      // EÄŸer hiÃ§ pending video yoksa, tÃ¼m kullanÄ±cÄ±larÄ± kontrol et (fallback)
      if (usersSnapshot.empty) {
        console.log('ðŸ“­ No users with pending videos flag, checking all users...');
        const allUsersSnapshot = await db.collection('users').get();
        let totalPendingVideos = 0;
        let totalCheckedVideos = 0;
        let totalCompletedVideos = 0;
        
        for (const userDoc of allUsersSnapshot.docs) {
          const userId = userDoc.id;
          const userData = userDoc.data();
          const videos = userData.userGeneratedVideos || [];
          
          // Processing statusundeki Pixverse Original videolarÄ± filtrele
          const pendingVideos = videos.filter(v =>
            v.model === 'pixverse-original-4.5' &&
            v.status === 'processing' &&
            (v.output === null || v.output === '') &&
            v.id != null &&
            v.trace_id != null
          );
          
          if (pendingVideos.length === 0) continue;
          
          totalPendingVideos += pendingVideos.length;
          console.log(`ðŸ“‹ User ${userId}: Found ${pendingVideos.length} pending videos`);
          
          // Her pending video iÃ§in status check
          for (const video of pendingVideos) {
            const videoId = video.id;
            const traceId = video.trace_id;
            
            try {
              totalCheckedVideos++;
              console.log(`ðŸ” Checking video ${videoId} for user ${userId}`);
              
              // Pixverse API'ye status check
              const response = await axios.get(
                `https://app-api.pixverse.ai/openapi/v2/video/result/${videoId}`,
                {
                  headers: {
                    'API-KEY': pixverseApiKey,
                    'Ai-trace-id': traceId
                  }
                }
              );
              
              if (response.status === 200 && response.data.ErrCode === 0) {
                const resp = response.data.Resp;
                
                // Status: 0 = processing, 1 = succeeded, 2 = failed
                if (resp.status === 1 && resp.url) {
                  // âœ… Video baÅŸarÄ±lÄ±
                  console.log(`âœ… Video ${videoId} completed! URL: ${resp.url}`);
                  
                  // Videoyu Firebase Storage'a yÃ¼kle
                  const firebaseUrl = await uploadPixverseVideoToFirebase(resp.url, userId, videoId);
                  
                  if (firebaseUrl) {
                    const updatedVideos = videos.map(v => {
                      if (v.id === videoId) {
                        return {
                          ...v,
                          output: firebaseUrl,
                          status: 'succeeded',
                          completedAt: new Date().toISOString()
                        };
                      }
                      return v;
                    });
                    
                    await db.collection('users').doc(userId).update({
                      userGeneratedVideos: updatedVideos,
                      lastVideoUpdate: new Date().toISOString(),
                      hasPendingVideos: false // Pending video yok artÄ±k
                    });
                    
                    totalCompletedVideos++;
                    console.log(`ðŸ’¾ Completed video ${videoId} updated in Firebase for user ${userId}`);
                  }
                  
                } else if (resp.status === 2) {
                  // âŒ Video baÅŸarÄ±sÄ±z
                  console.log(`âŒ Video ${videoId} failed!`);
                  
                  const updatedVideos = videos.map(v => {
                    if (v.id === videoId) {
                      return {
                        ...v,
                        status: 'failed',
                        error: 'Video generation failed',
                        completedAt: new Date().toISOString()
                      };
                    }
                    return v;
                  });
                  
                  await db.collection('users').doc(userId).update({
                    userGeneratedVideos: updatedVideos,
                    lastVideoUpdate: new Date().toISOString(),
                    hasPendingVideos: false // Pending video yok artÄ±k
                  });
                  
                  console.log(`ðŸ’¾ Failed video ${videoId} updated in Firebase for user ${userId}`);
                  
                } else {
                  // â³ Hala processing
                  console.log(`â³ Video ${videoId} still processing (status: ${resp.status})`);
                }
              }
              
            } catch (error) {
              console.error(`âš ï¸ Error checking video ${videoId}:`, error.message);
              // Continue with next video
            }
          }
        }
        
        console.log(`âœ… Fallback polling completed! Pending: ${totalPendingVideos}, Checked: ${totalCheckedVideos}, Completed: ${totalCompletedVideos}`);
        return null;
      }
      
      let totalPendingVideos = 0;
      let totalCheckedVideos = 0;
      let totalCompletedVideos = 0;
      
      for (const userDoc of usersSnapshot.docs) {
        const userId = userDoc.id;
        const userData = userDoc.data();
        const videos = userData.userGeneratedVideos || [];
        
            // Processing statusundeki Pixverse Original videolarÄ± filtrele
            const pendingVideos = videos.filter(v =>
              v.model === 'pixverse-original-4.5' &&
              v.status === 'processing' &&
              (v.output === null || v.output === '') &&
              v.id != null &&
              v.trace_id != null
            );
        
        if (pendingVideos.length === 0) continue;
        
        totalPendingVideos += pendingVideos.length;
        console.log(`ðŸ“‹ User ${userId}: Found ${pendingVideos.length} pending videos`);
        
            // Her pending video iÃ§in status check
            for (const video of pendingVideos) {
              const videoId = video.id;
              const traceId = video.trace_id;
          
          try {
            totalCheckedVideos++;
            console.log(`ðŸ” Checking video ${videoId} for user ${userId}`);
            
            // Pixverse API'ye status check
            const response = await axios.get(
              `https://app-api.pixverse.ai/openapi/v2/video/result/${videoId}`,
              {
                headers: {
                  'API-KEY': pixverseApiKey,
                  'Ai-trace-id': traceId
                }
              }
            );
            
            if (response.status === 200 && response.data.ErrCode === 0) {
              const resp = response.data.Resp;
              
              // Status: 0 = processing, 1 = succeeded, 2 = failed
              if (resp.status === 1 && resp.url) {
                // âœ… Video tamamlandÄ±!
                console.log(`âœ… Video ${videoId} completed! Pixverse URL: ${resp.url}`);
                totalCompletedVideos++;
                
                // Pixverse URL'den videoyu Firebase Storage'a yÃ¼kle
                let firebaseUrl;
                try {
                  firebaseUrl = await uploadPixverseVideoToFirebase(resp.url, userId, videoId);
                  console.log(`âœ… Video uploaded to Firebase Storage: ${firebaseUrl}`);
                } catch (uploadError) {
                  console.error(`âš ï¸ Failed to upload to Firebase Storage, using Pixverse URL: ${uploadError.message}`);
                  firebaseUrl = resp.url; // Fallback to Pixverse URL
                }
                
                // Firebase'i gÃ¼ncelle
                const updatedVideos = videos.map(v => {
                  if (v.id === videoId) {
                    return {
                      ...v,
                      status: 'succeeded',
                      output: firebaseUrl,
                      pixverseUrl: resp.url, // Orijinal URL'i de sakla
                      completedAt: new Date().toISOString()
                    };
                  }
                  return v;
                });
                
                await db.collection('users').doc(userId).update({
                  userGeneratedVideos: updatedVideos,
                  lastVideoUpdate: new Date().toISOString(),
                  hasPendingVideos: false // Pending video yok artÄ±k
                });
                
                console.log(`ðŸ’¾ Video ${videoId} updated in Firebase for user ${userId}`);
                
              } else if (resp.status === 2) {
                // âŒ Video baÅŸarÄ±sÄ±z
                console.log(`âŒ Video ${videoId} failed!`);
                
                const updatedVideos = videos.map(v => {
                  if (v.id === videoId) {
                    return {
                      ...v,
                      status: 'failed',
                      error: 'Video generation failed',
                      completedAt: new Date().toISOString()
                    };
                  }
                  return v;
                });
                
                await db.collection('users').doc(userId).update({
                  userGeneratedVideos: updatedVideos,
                  lastVideoUpdate: new Date().toISOString(),
                  hasPendingVideos: false // Pending video yok artÄ±k
                });
                
                console.log(`ðŸ’¾ Failed video ${videoId} updated in Firebase for user ${userId}`);
                
              } else {
                // â³ Hala processing
                console.log(`â³ Video ${videoId} still processing (status: ${resp.status})`);
              }
            }
            
          } catch (error) {
            console.error(`âš ï¸ Error checking video ${videoId}:`, error.message);
            // Continue with next video
          }
        }
      }
      
      console.log(`âœ… Polling completed! Pending: ${totalPendingVideos}, Checked: ${totalCheckedVideos}, Completed: ${totalCompletedVideos}`);
      return null;
      
    } catch (error) {
      console.error('âŒ Error in checkPendingPixverseVideos:', error);
      return null;
    }
  });

// ===== BONUS CREDIT SYSTEM =====

// First Install Bonus - Ä°lk yÃ¼klemede kredi verme
exports.claimFirstInstallBonus = functions.https.onCall(async (data, context) => {
  try {
    // 1. Auth kontrolÃ¼
    if (!context.auth) {
      console.error('âŒ Unauthenticated request for first install bonus');
      throw new functions.https.HttpsError('unauthenticated', 'KullanÄ±cÄ± giriÅŸi gerekli');
    }
    
    const userId = context.auth.uid;
    const deviceId = data.deviceId;
    const authProvider = data.authProvider || 'unknown';
    
    console.log(`ðŸŽ First install bonus request: userId=${userId}, deviceId=${deviceId}, provider=${authProvider}`);
    
    // 2. Parametreleri kontrol et
    if (!deviceId || typeof deviceId !== 'string' || deviceId.length < 10) {
      console.error('âŒ Invalid device ID:', deviceId);
      throw new functions.https.HttpsError('invalid-argument', 'GeÃ§ersiz cihaz ID');
    }
    
    const db = admin.firestore();
    
    // 3. KullanÄ±cÄ± kontrolÃ¼ - BU KULLANICI DAHA Ã–NCE ALDI MI?
    const userDoc = await db.collection('users').doc(userId).get();
    if (userDoc.exists) {
      const userData = userDoc.data();
      const hasUserBonus = userData?.profile_info?.hasReceivedFirstInstallBonus || false;
      if (hasUserBonus) {
        console.log(`âŒ User already received first install bonus: ${userId}`);
        throw new functions.https.HttpsError('already-exists', 'Bu kullanÄ±cÄ± daha Ã¶nce bonus aldÄ±');
      }
    }
    
    // 4. Cihaz kontrolÃ¼ - BU CÄ°HAZ DAHA Ã–NCE KULLANILDI MI?
    const deviceDoc = await db.collection('device_first_install_bonus').doc(deviceId).get();
    if (deviceDoc.exists && deviceDoc.data()?.claimed === true) {
      console.log(`âŒ Device already used for first install bonus: ${deviceId}`);
      throw new functions.https.HttpsError('already-exists', 'Bu cihazdan daha Ã¶nce bonus alÄ±ndÄ±');
    }
    
    // 5. Firebase'den bonus miktarÄ±nÄ± al
    const creditDoc = await db.collection('generate_credit').doc('credit_campaign').get();
    let bonusAmount = 120; // Default fallback
    
    if (creditDoc.exists && creditDoc.data()) {
      bonusAmount = creditDoc.data().opened_credit_count || 120;
    }
    
    console.log(`ðŸ’° First install bonus amount: ${bonusAmount}`);
    
    // 6. Transaction ile atomik iÅŸlem
    await db.runTransaction(async (transaction) => {
      // User'a kredi ekle ve flag gÃ¼ncelle
      const userRef = db.collection('users').doc(userId);
      transaction.update(userRef, {
        'profile_info.totalCredit': admin.firestore.FieldValue.increment(bonusAmount),
        'profile_info.hasReceivedFirstInstallBonus': true,
        'profile_info.firstInstallBonusDate': admin.firestore.FieldValue.serverTimestamp()
      });
      
      // CihazÄ± iÅŸaretle - BU CÄ°HAZ ARTIK KULLANILAMAZ
      const deviceRef = db.collection('device_first_install_bonus').doc(deviceId);
      transaction.set(deviceRef, {
        claimed: true,
        claimedAt: admin.firestore.FieldValue.serverTimestamp(),
        deviceId: deviceId,
        userId: userId,
        authProvider: authProvider,
        creditAmount: bonusAmount,
        userAgent: context.rawRequest?.headers?.['user-agent'] || 'unknown',
        ipAddress: context.rawRequest?.ip || 'unknown'
      });
    });
    
    console.log(`ðŸŽ‰ First install bonus granted: ${userId}, ${bonusAmount} credits`);
    
    return {
      success: true,
      creditAmount: bonusAmount,
      message: 'Ä°lk yÃ¼kleme bonusu baÅŸarÄ±yla eklendi!'
    };
    
  } catch (error) {
    console.error('âŒ Error in claimFirstInstallBonus:', error);
    
    // EÄŸer zaten HttpsError ise, direkt throw et
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    // DiÄŸer hatalar iÃ§in genel hata mesajÄ±
    throw new functions.https.HttpsError('internal', 'Bonus eklenirken hata oluÅŸtu');
  }
});

// Review Credit - Yorum sonrasÄ± kredi verme
exports.claimReviewCredit = functions.https.onCall(async (data, context) => {
  try {
    // 1. Auth kontrolÃ¼
    if (!context.auth) {
      console.error('âŒ Unauthenticated request for review credit');
      throw new functions.https.HttpsError('unauthenticated', 'KullanÄ±cÄ± giriÅŸi gerekli');
    }
    
    const userId = context.auth.uid;
    const deviceId = data.deviceId;
    const rating = data.rating;
    
    console.log(`â­ Review credit request: userId=${userId}, deviceId=${deviceId}, rating=${rating}`);
    
    // 2. Parametreleri kontrol et
    if (!deviceId || typeof deviceId !== 'string' || deviceId.length < 10) {
      console.error('âŒ Invalid device ID:', deviceId);
      throw new functions.https.HttpsError('invalid-argument', 'GeÃ§ersiz cihaz ID');
    }
    
    if (!rating || typeof rating !== 'number' || rating < 1 || rating > 5) {
      console.error('âŒ Invalid rating:', rating);
      throw new functions.https.HttpsError('invalid-argument', 'GeÃ§ersiz rating deÄŸeri');
    }
    
    const db = admin.firestore();
    
    // 3. KullanÄ±cÄ± kontrolÃ¼ - BU KULLANICI DAHA Ã–NCE ALDI MI?
    const userDoc = await db.collection('users').doc(userId).get();
    if (userDoc.exists) {
      const userData = userDoc.data();
      const hasReviewCredit = userData?.profile_info?.hasReceivedReviewCredit || false;
      if (hasReviewCredit) {
        console.log(`âŒ User already received review credit: ${userId}`);
        throw new functions.https.HttpsError('already-exists', 'Bu kullanÄ±cÄ± daha Ã¶nce review kredisi aldÄ±');
      }
    }
    
    // 4. Cihaz kontrolÃ¼ - BU CÄ°HAZ DAHA Ã–NCE KULLANILDI MI?
    const deviceDoc = await db.collection('device_review_credits').doc(deviceId).get();
    if (deviceDoc.exists && deviceDoc.data()?.claimed === true) {
      console.log(`âŒ Device already used for review credit: ${deviceId}`);
      throw new functions.https.HttpsError('already-exists', 'Bu cihazdan daha Ã¶nce review kredisi alÄ±ndÄ±');
    }
    
    // 5. Firebase'den review credit miktarÄ±nÄ± al
    const creditDoc = await db.collection('generate_credit').doc('credit_campaign').get();
    let reviewCreditAmount = 120; // Default fallback
    
    if (creditDoc.exists && creditDoc.data()) {
      reviewCreditAmount = creditDoc.data().review_credit || 120;
    }
    
    console.log(`ðŸ’° Review credit amount: ${reviewCreditAmount}`);
    
    // 6. Transaction ile atomik iÅŸlem
    await db.runTransaction(async (transaction) => {
      // User'a kredi ekle ve flag gÃ¼ncelle
      const userRef = db.collection('users').doc(userId);
      transaction.update(userRef, {
        'profile_info.totalCredit': admin.firestore.FieldValue.increment(reviewCreditAmount),
        'profile_info.hasReceivedReviewCredit': true,
        'profile_info.reviewCreditDate': admin.firestore.FieldValue.serverTimestamp(),
        'profile_info.reviewRating': rating
      });
      
      // CihazÄ± iÅŸaretle - BU CÄ°HAZ ARTIK KULLANILAMAZ
      const deviceRef = db.collection('device_review_credits').doc(deviceId);
      transaction.set(deviceRef, {
        claimed: true,
        claimedAt: admin.firestore.FieldValue.serverTimestamp(),
        deviceId: deviceId,
        userId: userId,
        userEmail: context.auth.token.email || 'unknown',
        creditAmount: reviewCreditAmount,
        rating: rating,
        userAgent: context.rawRequest?.headers?.['user-agent'] || 'unknown',
        ipAddress: context.rawRequest?.ip || 'unknown'
      });
    });
    
    console.log(`ðŸŽ‰ Review credit granted: ${userId}, ${reviewCreditAmount} credits`);
    
    return {
      success: true,
      creditAmount: reviewCreditAmount,
      message: 'Review kredisi baÅŸarÄ±yla eklendi!'
    };
    
  } catch (error) {
    console.error('âŒ Error in claimReviewCredit:', error);
    
    // EÄŸer zaten HttpsError ise, direkt throw et
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    // DiÄŸer hatalar iÃ§in genel hata mesajÄ±
    throw new functions.https.HttpsError('internal', 'Review kredisi eklenirken hata oluÅŸtu');
  }
});
